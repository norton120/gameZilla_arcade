var levelOneState = {

create: function(){ 
    

    game.world.setBounds(0,0,4000,768);
    game.stage.backgroundColor = "#7EC0EE";
      
/*Coin Listener*/
    if(!game.hardwareInterface.coinMode.freePlay){
      game.time.events.loop(500,game.checkForCoins,this);
    }


/*Platforms*/
    this.street = game.add.tileSprite(0,468, 4000, 300, 'concrete');
    game.physics.enable(this.street, Phaser.Physics.ARCADE);
    this.street.enableBody = true;
    
/*Action Groups*/
  /* these can be phaser groups or arrays, since phaser
   * only supports a single group per sprite
   */  
    // group for the depth sorting
    this.actors = game.add.group();

/*Players*/
    
    // cycle through players, if active set character
    for(x=1; x<4; x++){
      var player = game.players['player'+x];
      if(player.active){
        this.addPlayerToGame(game,player,player.displayName,100,308+(x*100));            
      }
      else{
        player.hud = new HUDPlaceholder(game, player.displayName, (x-1)*340+10, 25);
      }	      
    }	

/*Baddies*/
  
  this.baddies = [];  

    // 2 trolls initially
    this.trolls = [];
    for(x=0;x<2;x++){
      troll = new Troll(game, 750, 400+(x*170));
      this.actors.add(troll);
      this.trolls.push(troll);
    }
  this.baddies.push(this.trolls);
},

update: function(){

/*Setup*/	

    // create the active players array
    this.activePlayers = this.getActivePlayers();
    
    // normalize the gamepad inputs	  
    game.updateInputKeyStates();	  
    
    // depth sort the players
    this.actors.sort('y',Phaser.Group.SORT_ASCENDING);

    console.log(this.getPlayerFurthest(this.getNestedSprites("hero",this.activePlayers)),"right");
/*camera*/
    // adjust camera for multiplayers
    (function(){
      var players = [];
      for (x=1;x<4; x++){
 	if(game.players['player'+x].active){players.push(game.players['player'+x]);}      
      }	      

      var heros = [];	    
      // follow player to the right
      for(x=0;x<players.length;x++){
        heros.push(players[x].hero);
      }  
      game.moveCamera(heros);
     
      if(players.length > 1){
	players.map(function(p){p.hero.rightFreeze = false;p.hero.leftFreeze = false;}); 
	// more room before scrolling for play      
        game.camera.deadzone = new Phaser.Rectangle(20,20,800,700);
        // set movement freeze to keep all players inbounds
	game.freezePlayers(heros); 
      }

    })();


/*collisions*/
    // collide all characters that are depth sorted
  /*  game.physics.arcade.collide(this.actors);
 /*   
    // create an array of hero avatars for collisions
    this.activePlayerHeroAvatars = [];
    for(x=0;x<this.players.length; x++){
      this.activePlayerHeroAvatars.push(this.activePlayers[x].hero.avatar);
    }
    
    // create an array of baddies for collisions
    this.activeBaddyAvatars = [];
    for(b=0;b<this.baddies.length;b++){
      for(a=0;a<this.baddies[b].length;a++){
        this.activeBaddyAvatars.push(this.baddies[b][a].avatar);	      
      }
    }
    // baddy-player basic hit collisions
  /*  for(x=0; x<this.activeBaddyAvatars.length; x++){
      game.physics.arcade.overlap(this.activePlayerHeroAvatars,this.activeBaddyAvatars[x],function(h,e){this.hitPlayer(h.parent,1);},null, this);
    }
*/
 /*   this.overlapWithPlayers(this.activeBaddyAvatars, function(x){this.hitPlayer(x.parent,1);});


    //TODO: Convert this to an overlap of the projectiles and the baddies. 
    // might need to make the hit box on the projectile much taller to compensate. 
    // baddy weapons collisions
    for(x=0; x<this.activePlayerHeroAvatars.length; x++){
      game.physics.arcade.overlap(this.activePlayerHeroAvatars[x].primaryWeapon, this.activeBaddyAvatars, function(h,e){h.exists = false; e.hit(1);},null,this);
    }	    


    

/*Player Controls and apperance*/
    for(x=1; x<4; x++){
      var player = game.players['player'+x];    
      if(player.active && !player.hero.isHit){
	player.hero.alpha = player.hero.ghost? .4 : 1;	
 
        // start each pass 0 velocity
        // so hero stops if no keys pressed  	  
        player.hero.body.velocity.x = 0;
        if(!player.hero.jumping){player.hero.body.velocity.y = 0;}

        // fire key
        if(player.controls.firePressed && !player.hero.jumping){player.hero.fire();} 
    
        // jump key
        if(player.controls.jumpPressed && !player.hero.isFiring){player.hero.jump();}	

        // Z-axis cursors
        if(player.controls.downPressed  && (player.controls.rightPressed || player.controls.leftPressed) && !player.hero.jumping && (player.hero.feet() < (this.street.bottom -30))){player.hero.moveDown();}
   
        if(player.controls.upPressed &&(player.controls.rightPressed || player.controls.leftPressed) && !player.hero.jumping && (player.hero.feet() > (this.street.top +30))){player.hero.moveUp();}

        // X-axis cursor keys
        if(player.controls.rightPressed){
	  if(player.hero.jumping){
 	    player.hero.moveRight();	  
	  }
	  else{	  
            player.hero.run('right',player.hero.isFiring, player.hero.rightFreeze);	    
          }	
	}
        else if(player.controls.leftPressed){
	  if(player.hero.jumping){
	    player.hero.moveLeft();	  
	  }
	  else{	  
            player.hero.run('left',player.hero.isFiring, player.hero.leftFreeze);	    
        
	  }
	}  
        else if(!player.hero.jumping && !player.hero.isFiring)
        {
          player.hero.standStill();	    
        }
      }
      else if(player.controls.startPressed && (game.hardwareInterface.coinMode.freePlay || game.coinCredit>0)){
	player.hud.container.destroy();
        this.addPlayerToGame(game,player,player.displayName, game.camera.target.x, 348); 
	game.coinCredit--;
      }
      // update the top bar HUD's
      player.hud.update();      
    }

/*Baddie AI*/
     this.trolls.map(function(troll){
      var players = [];
      for(x=1;x<3;x++){if(game.players['player'+x].active){players.push(game.players['player'+x].hero);}}	     
      if(troll.exists){ troll.AI('left',true,players);}
     });
  },

insertHero: function(player, x, y){
  player.hero.health = 5;
  player.ghost = true;
  player.exists = true;
  player.reset(x,y);
},  

addPlayerToGame: function(game,player, character, x, y){
  player.active = true;
  var hudX;	
  switch (character){
    case 'Anthony':
     player.hero = new Anthony(game,x, y);
     player.hero.visible = false;
     game.add.existing(player.hero);
     hudX = 2;
     break;
      
    case 'Matt':
     player.hero = new Matt(game,x,y);
     game.add.existing(player.hero);
     hudX =0;   	
     break;

    case 'Nick':
     player.hero = new Matt(game,x,y);
     game.add.existing(player.hero);
     hudX =1;
     break;
  }
 this.actors.add(player.hero); 
 player.hud = new HUD(game, player.displayName, player.hero, (hudX)*340+10 ,10);
 this.ghostIn(player.hero);
 game.time.events.add(400, function(){player.hero.visible = true;},this); 
},
ghostIn: function(hero){
  var time = 100;	
  game.time.events.add(1500, function(){game.time.events.repeat(time,15,function(){hero.ghost= !hero.ghost; time=Math.floor(time*.5);},this)},this);
  game.time.events.add(3500, function(){hero.ghost=false;});
},
hitPlayer: function(player,damage){
 if(!player.ghost){
 player.hit(damage);
 } 
},

// returns an array of active players	
getActivePlayers: function(){
  var players = [];
  for(x=1;x<4;x++){
    if(game.players['player'+x].active){players.push(game.players['player'+x]);}	  }	
  return players;   
},

// overlap with active player hero avatars
overlapWithPlayers: function(collider,callback){
  var players = this.activePlayers();
  var avatars = [];
  for(x=0;x<players.length;x++){
    avatars.push(players[x].hero.avatar);
  }
  for(x<0;x<avatars.length;x++){
    game.physics.arcade.overlap(avatars[x],collider,callback,null,this);
  }
},
// returns an array of sprites matching the sprite name
// @param {string}|| {array} spriteName the object name of the sprite. if an array, flattened
//      and nested in array order. so top.middle.target would be ["middle","target"]
// @param {array} collection the array to traverse	
getNestedSprites(spriteName, players){
  var result = [];
  for(x=0;x<players.length;x++){
    if(Array.isArray(spriteName)){
      var path= players[x]; 
      for(y=0;y<spriteName.length;y++){
        path = path[spriteName[y]];
      }
      result.push(path);
    }
    else{
      result.push(players[x][spriteName]);  	    
    }
  }
  return result;
},	
// returns an array of player heros
// @param {array} players the players to grab heros from	
getPlayerHeros: function(players){
  var heros =[];
  for(x=0;x<players.length;x++){
    heros.push(players[x].hero);
  }
  return heros;
},	
// returns an array of player avatars
// @param {array} players the players to grab avatars from	
getPlayerAvatars: function(players){
  var avatars = [];
  for(x=0;x<players.length;x++){
    avatars.push(players[x].hero.avatar);
  }
  return avatars;  
},	
// returns the player furthest to the one side of the game screen
// @param {array} players the players to compare
// @param {string} side which side of the screen. Options ["left","right"]	
getPlayerFurthest: function(players, side){
  var furthest = players[0];
  for(x=0; x<players.length;x++){
    if(side == "right"){
      if(players[x].world.x > furthest.world.x){furthest = players[x];}	    
    }
    else{
      if(players[x].world.x < furthest.world.x){furthest = players[x];}	    
    }
  }
  return furthest;  
}

};
